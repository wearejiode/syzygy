name: Auto-Label INTO Project Priority from P0/P1/P2 labels

on:
  issues:
    types: [labeled, unlabeled, opened, edited]

# IMPORTANT:
# - Project (v2) must be shared with this repo (Project → Share → Add repositories)
# - This token scope is required to read/write Projects data
permissions:
  contents: read
  issues: read
  repository-projects: write

env:
  # Configure your user project location
  PROJECT_OWNER: wearejiode           # your GitHub USER login (not org)
  PROJECT_TITLE: "Luna-Improvements"  # exact title (preferred)
  PROJECT_NUMBER: ""                  # or a number, leave TITLE empty to use this
  PRIORITY_FIELD_NAME: Priority       # Project single-select field
  # Label → Option mapping
  MAP_P0: P0
  MAP_P1: P1
  MAP_P2: P2
  MAP_P3: P3
  MAP_PZ: PZ

jobs:
  sync-priority:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # gh will auto-auth with this
    steps:
      - name: Show event (debug)
        run: |
          jq -C . < "$GITHUB_EVENT_PATH" | sed 's/^/event: /'

      - name: Resolve desired Priority from labels
        id: want
        shell: bash
        run: |
          # Read labels on this issue from the webhook payload
          lbls=$(jq -r '.issue.labels[] | .name // empty' "$GITHUB_EVENT_PATH" | tr '\n' ',')
          echo "labels: $lbls"

          # Map repo labels to project options
          want=""
          if echo "$lbls" | grep -q 'P0:Blocking'; then want="${MAP_P0}"; fi
          if echo "$lbls" | grep -q 'P1:Critical'; then want="${MAP_P1}"; fi
          if echo "$lbls" | grep -q 'P2:High';     then want="${MAP_P2}"; fi
          if echo "$lbls" | grep -q 'P3:Med';      then want="${MAP_P3}"; fi
          if echo "$lbls" | grep -q 'PZ:Low';      then want="${MAP_PZ}"; fi

          echo "want=$want" | tee -a "$GITHUB_OUTPUT"

      - name: Lookup Project (user) by TITLE or NUMBER
        id: project
        shell: bash
        run: |
          owner="${PROJECT_OWNER:-${GITHUB_REPOSITORY%%/*}}"
          title="${PROJECT_TITLE}"
          number="${PROJECT_NUMBER}"

          if [[ -n "$title" ]]; then
            data=$(gh api graphql -f query='
              query($login:String!){
                user(login:$login){
                  projectsV2(first:50){
                    nodes { id title number }
                  }
                }
              }' -f login="$owner")
            echo "$data" | jq .
            proj=$(echo "$data" | jq -r --arg t "$title" '.data.user.projectsV2.nodes[] | select(.title==$t)')
          else
            # resolve specific number
            data=$(gh api graphql -f query='
              query($login:String!, $num:Int!){
                user(login:$login){ projectV2(number:$num){ id title number } }
              }' -f login="$owner" -F num="$number")
            echo "$data" | jq .
            proj=$(echo "$data" | jq -r '.data.user.projectV2')
          fi

          if [[ -z "$proj" || "$proj" == "null" ]]; then
            echo "::error::Project not found for user '$owner' (title=$title, number=$number). Did you share it with this repo?"
            exit 1
          fi

          proj_id=$(echo "$proj" | jq -r '.id')
          proj_title=$(echo "$proj" | jq -r '.title')
          echo "id=$proj_id"       >> "$GITHUB_OUTPUT"
          echo "title=$proj_title" >> "$GITHUB_OUTPUT"

      - name: Get Issue node id
        id: issue
        shell: bash
        run: |
          owner="${GITHUB_REPOSITORY%%/*}"
          repo="${GITHUB_REPOSITORY##*/}"
          num=$(jq -r '.issue.number' "$GITHUB_EVENT_PATH")

          # REST returns node_id which we can use in GraphQL mutations
          node_id=$(gh api repos/$owner/$repo/issues/$num --jq .node_id)
          echo "node_id=$node_id" >> "$GITHUB_OUTPUT"
          echo "issue_num=$num"   >> "$GITHUB_OUTPUT"

      - name: Ensure Issue is in Project (add if needed)
        id: item
        shell: bash
        run: |
          proj="${{ steps.project.outputs.id }}"
          owner="${GITHUB_REPOSITORY%%/*}"
          repo="${GITHUB_REPOSITORY##*/}"
          num="${{ steps.issue.outputs.issue_num }}"
          issue_node="${{ steps.issue.outputs.node_id }}"

          # Try to find an existing item referencing this issue
          search=$(gh api graphql -f query='
            query($proj:ID!, $q:String!){
              node(id:$proj){
                ... on ProjectV2 {
                  items(first:100, query:$q){
                    nodes { id content { __typename ... on Issue { id } } }
                  }
                }
              }
            }' -f proj="$proj" -f q="repo:$owner/$repo is:issue #$num")
          echo "$search" | jq .
          item_id=$(echo "$search" | jq -r --arg id "$issue_node" '.data.node.items.nodes[] | select(.content.id==$id) | .id')

          if [[ -z "$item_id" ]]; then
            add=$(gh api graphql -f query='
              mutation($proj:ID!, $content:ID!){
                addProjectV2ItemById(input:{projectId:$proj, contentId:$content}) { item { id } }
              }' -f proj="$proj" -f content="$issue_node")
            echo "$add" | jq .
            item_id=$(echo "$add" | jq -r '.data.addProjectV2ItemById.item.id')
          fi

          echo "item_id=$item_id" >> "$GITHUB_OUTPUT"

      - name: Get Priority field + desired option id
        id: field
        shell: bash
        run: |
          proj="${{ steps.project.outputs.id }}"
          want="${{ steps.want.outputs.want }}"
          field_name="${PRIORITY_FIELD_NAME}"

          fields=$(gh api graphql -f query='
            query($proj:ID!){
              node(id:$proj){
                ... on ProjectV2 {
                  fields(first:50){
                    nodes {
                      __typename
                      ... on ProjectV2FieldCommon { id name }
                      ... on ProjectV2SingleSelectField { id name options { id name } }
                    }
                  }
                }
              }
            }' -f proj="$proj")
          echo "$fields" | jq .

          field_id=$(echo "$fields" | jq -r --arg n "$field_name" \
            '.data.node.fields.nodes[] | select(.name==$n and .options) | .id')
          if [[ -z "$field_id" ]]; then
            echo "::error::Single-select field '$field_name' not found on project '${{ steps.project.outputs.title }}'."
            exit 1
          fi

          if [[ -n "$want" ]]; then
            opt_id=$(echo "$fields" | jq -r --arg n "$field_name" --arg o "$want" \
              '.data.node.fields.nodes[] | select(.name==$n and .options) | .options[] | select(.name==$o) | .id')
          else
            opt_id=""
          fi

          echo "field_id=$field_id" >> "$GITHUB_OUTPUT"
          echo "opt_id=$opt_id"     >> "$GITHUB_OUTPUT"
          echo "want=$want"         >> "$GITHUB_OUTPUT"

      - name: Update Project Priority field
        if: always()
        shell: bash
        run: |
          proj="${{ steps.project.outputs.id }}"
          item="${{ steps.item.outputs.item_id }}"
          field="${{ steps.field.outputs.field_id }}"
          opt="${{ steps.field.outputs.opt_id }}"
          want="${{ steps.field.outputs.want }}"

          if [[ -n "$opt" ]]; then
            echo "Setting Priority → $want"
            gh api graphql -f query='
              mutation($proj:ID!, $item:ID!, $field:ID!, $opt:String!){
                updateProjectV2ItemFieldValue(input:{
                  projectId:$proj, itemId:$item, fieldId:$field,
                  value:{ singleSelectOptionId: $opt }
                }) { clientMutationId }
              }' -f proj="$proj" -f item="$item" -f field="$field" -f opt="$opt"
          else
            echo "Clearing Priority (no P* label present)"
            gh api graphql -f query='
              mutation($proj:ID!, $item:ID!, $field:ID!){
                updateProjectV2ItemFieldValue(input:{
                  projectId:$proj, itemId:$item, fieldId:$field,
                  value:{ singleSelectOptionId: null }
                }) { clientMutationId }
              }' -f proj="$proj" -f item="$item" -f field="$field"
          fi
