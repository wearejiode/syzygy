name: Auto-Label INTO Project Priority from P0/P1/P2 labels
on:
  issues:
    types: [labeled, unlabeled, opened, edited]

permissions:
  contents: read
  # repository-projects is for classic Projects; Projects v2 uses "projects"

env:
  # Set these two to your user project’s owner + number
  PROJECT_OWNER: wearejiode # user login (not an org)
  PROJECT_NUMBER: ''
  PROJECT_TITLE: 'Luna-Improvements'
  PRIORITY_FIELD_NAME: Priority

# NOTE: For *private* user Projects (Projects v2), you must open the Project → Share →
# “Add repositories”, and add this repository. Otherwise the GITHUB_TOKEN cannot
# read/write the project and you’ll see GraphQL NOT_FOUND errors.

# When an issue is opened/edited/labeled/unlabeled, we check for labels P0/P1/P2/P3/PZ.
# We ensure the issue is in your Project, then set the Project’s Priority single-select field accordingly.
# If no P* label is present, we clear the field.
# Replace ORG, PROJECT_NUMBER, and (if needed) PRIORITY_FIELD_NAME.
# In your Project, create a single-select field named Priority with options P0, P1, P2, P3, PZ.

jobs:
  sync-priority:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const projectTitle = 'Luna - Planned Improvements'; // or use number
            const priorityField = 'Priority';
            const map = { 'P0:Blocking':'P0', 'P1:Critical':'P1', 'P2:High':'P2', 'P3:Med':'P3', 'PZ:Low':'PZ' };

            const labels = (context.payload.issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const chosen = Object.keys(map).find(n => labels.includes(n));
            const desired = chosen ? map[chosen] : null;

            const q = (query, vars) => github.graphql(query, vars);

            // 1) Find user project by title (repo must be linked to this project)
            const { user } = await q(`
              query($login:String!, $title:String!) {
                user(login:$login) {
                  projectsV2(first:50, query:$title) {
                    nodes { id title fields(first:50) {
                      nodes { ... on ProjectV2FieldCommon { id name }
                              ... on ProjectV2SingleSelectField { id name options { id name } } }
                    } }
                  }
                }
              }`,
              { login: context.repo.owner, title: projectTitle }
            );
            const project = user.projectsV2.nodes.find(p => p.title === projectTitle);
            if (!project) core.setFailed(`Project "${projectTitle}" not found or repo not linked.`);

            // 2) Ensure the issue is in the project
            const { repository } = await q(`
              query($owner:String!, $repo:String!, $num:Int!) {
                repository(owner:$owner, name:$repo) { issue(number:$num) { id } }
              }`,
              { owner: context.repo.owner, repo: context.repo.repo, num: context.payload.issue.number }
            );
            const issueId = repository.issue.id;

            const search = await q(`
              query($proj:ID!, $q:String!) {
                node(id:$proj) { ... on ProjectV2 { items(first:100, query:$q) {
                  nodes { id content { ... on Issue { id } } } } }
              }`,
              { proj: project.id, q: `repo:${context.repo.owner}/${context.repo.repo} is:issue #${context.payload.issue.number}` }
            );
            let itemId = search.node.items.nodes.find(n => n.content?.id === issueId)?.id;
            if (!itemId) {
              const add = await q(`
                mutation($proj:ID!, $content:ID!) {
                  addProjectV2ItemById(input:{projectId:$proj, contentId:$content}) { item { id } }
                }`, { proj: project.id, content: issueId });
              itemId = add.addProjectV2ItemById.item.id;
            }

            // 3) Set Priority (if label mapped)
            const field = project.fields.nodes.find(f => f.name === priorityField && f.options);
            if (!field) core.setFailed(`Project field "${priorityField}" not found or not single-select.`);
            const optId = desired ? field.options.find(o => o.name === desired)?.id : null;

            await q(`
              mutation($proj:ID!, $item:ID!, $field:ID!, $opt:String) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$proj, itemId:$item, fieldId:$field,
                  value:{ singleSelectOptionId:$opt }
                }) { clientMutationId }
              }`,
              { proj: project.id, item: itemId, field: field.id, opt: optId || null }
            );
            core.info(`Priority set to ${desired ?? 'cleared'}.`);
